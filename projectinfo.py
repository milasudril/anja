#@  {
#@  "targets":
#@      [{
#@		 "name":"projectinfo.hpp"
#@		,"dependencies":[{"ref":"externals.json","rel":"misc"}
#@			,{"ref":"maikeconfig.json","rel":"misc"}
#@			,{"ref":"projectinfo.json","rel":"misc"}]
#@		,"status_check":"dynamic"
#@		},{
#@		 "name":"versioninfo.txt"
#@		,"dependencies":[{"ref":"externals.json","rel":"misc"}
#@			,{"ref":"maikeconfig.json","rel":"misc"}
#@			,{"ref":"projectinfo.json","rel":"misc"}]
#@		,"status_check":"dynamic"
#@		}]
#@  }

import sys
import json
import string
import time
import subprocess
import shutil
import os

def write_error(*args, **kwargs):
    print(*args,file=sys.stderr,**kwargs)

projinfo_template=string.Template('''/*Information about $projname
*
* This file has been generated by $srcfile on $date.
* Any changes to this file may be overwritten during compilation.
*/

#ifndef ANJA_PROJECTINFO_HPP
#define ANJA_PROJECTINFO_HPP

namespace Anja
	{
	struct ProjectInfo
		{
		public:
			static constexpr const char* name() noexcept
				{return s_projname;}

			static constexpr const char* revision() noexcept
				{return s_revision;}

			static constexpr const char* nameAndRevision() noexcept
				{return s_name_rev;}

			static constexpr const char* description() noexcept
				{return s_description;}

			static constexpr const char* author() noexcept
				{return s_author;}

			static constexpr const char* years() noexcept
				{return s_years;}

			static constexpr const char* copyright() noexcept
				{return s_copyright;}

			static constexpr const char* const* acknowledgement() noexcept
				{return s_acknowledgement;}

			static constexpr const char* acknowledgementAll() noexcept
				{return s_acknowledgement_all;}

			static constexpr const char* legalBrief() noexcept
				{return s_legal_brief;}

			static constexpr const char* const* libraries() noexcept
				{return s_libraries;}

			static constexpr const char* const* tools() noexcept
				{return s_tools;}

			static constexpr const char* compilationDate() noexcept
				{return s_compilation_date;}

			static constexpr const char* compiler() noexcept
				{return s_compiler;}

			static constexpr const char* architecture() noexcept
				{return s_architecture;}

			static constexpr const char* techstring() noexcept
				{return s_techstring;}

		private:
			static constexpr const char* s_projname="$projname";
			static constexpr const char* s_revision="$revision";
			static constexpr const char* s_name_rev="$projname, $revision";
			static constexpr const char* s_description="$description";
			static constexpr const char* s_author="$author";
			static constexpr const char* s_years="$years";
			static constexpr const char* s_copyright="©\xa0$years\xa0$author";
			static constexpr const char* s_acknowledgement[]={"$acknowledgement",nullptr};
			static constexpr const char* s_acknowledgement_all="$acknowledgement_all";
			static constexpr const char* s_legal_brief="$legal_brief";
			static constexpr const char* s_libraries[]={"$libraries",nullptr};
			static constexpr const char* s_tools[]={"$tools",nullptr};
			static constexpr const char* s_compilation_date="$date";
			static constexpr const char* s_compiler="$compiler";
			static constexpr const char* s_architecture="$architecture";
			static constexpr const char* s_techstring="This $projname was "
				"compiled for $architecture by\\n$compiler, on $date, using $libstring.";
		};
	}

#endif
''')

def load(filename):
	with open(filename,encoding='utf-8') as input:
		return json.load(input)

def compiler_name(config):
	for hook in config['target_hooks']:
		if hook['name']=='targetcxx_default':
			return hook['config']['objcompile']['name']

def compiler_version(exename):
	with subprocess.Popen([exename,'--version'] \
		,stdout=subprocess.PIPE) as compiler:
		for lines in compiler.stdout:
			return lines.decode('utf8').rstrip()

def modified_time(filename):
	try:
		return (os.path.getmtime(filename),True)
	except (KeyboardInterrupt, SystemExit):
		raise
	except:
		return (0,False)

def newer(file_a,file_b):
	mod_a=modified_time(file_a)
	mod_b=modified_time(file_b)
	if mod_a[1]==False and mod_b[1]==False:
		raise OSError('Error: None of the files %s, and %s are accessible.'%(file_a,file_b))

	if not mod_a[1]:
		return False

	if not mod_b[1]:
		return True

	return mod_a[0] > mod_b[0]

def newer_than_all(file_a, files):
	for file in files:
		print('Is %s newer than %s?'%(file,file_a))
		if newer(file,file_a):
			print('Yes')
			return False
	print('No')
	return True

def git_changes():
	with subprocess.Popen(('git', 'status','--porcelain'),stdout=subprocess.PIPE) \
		as git:
		result=[];
		for k in filter(None,git.stdout.read().decode().split('\n')):
			result.append( k[3:].split(' ')[0] )
	return result


def get_revision(target_dir):
	if shutil.which('git')==None:
		if newer_than_all(target_dir + '/projectinfo.hpp' \
			,('projectinfo.json',target_dir + '/maikeconfig.json'\
				,target_dir + '/externals.json','projectinfo.py','versioninfo.txt')):
			sys.exit(0)

		with open('versioninfo.txt') as versionfile:
			result=versionfile.read().decode().strip()
		with open(target_dir+'/versioninfo.txt','w') as versionfile:
			versionfile.write(result)
	else:
		with subprocess.Popen(('git', 'describe','--tags','--dirty','--always') \
			,stdout=subprocess.PIPE) as git:
			result=git.stdout.read().decode().strip()
			git.wait()
			status=git.returncode

		if status:
			if newer_than_all(target_dir + '/projectinfo.hpp' \
				,('projectinfo.json',target_dir + '/maikeconfig.json'\
					,target_dir + '/externals.json','projectinfo.py','versioninfo.txt')):
				sys.exit(0)

			with open('versioninfo.txt') as versionfile:
				result=versionfile.read().strip()
			with open(target_dir+'/versioninfo.txt','w') as versionfile:
				versionfile.write(result)
		else:
			project_changed=( len(list(filter(lambda x:x!='versioninfo.txt',git_changes()))) > 0)
			with os.fdopen(os.open('versioninfo.txt',os.O_RDONLY|os.O_CREAT),'r') \
				as verfile:
				result_old=verfile.read().strip()
				if (result==result_old or (not project_changed and 'dirty' in result) ) \
					and newer_than_all(target_dir + '/projectinfo.hpp' \
						,('projectinfo.json' \
							,target_dir + '/maikeconfig.json' \
							,target_dir + '/externals.json' \
							,'projectinfo.py','versioninfo.txt')):
					sys.exit(0)

			with open('versioninfo.txt','w') as versionfile:
				versionfile.write(result)
			with open(target_dir+'/versioninfo.txt','w') as versionfile:
				versionfile.write(result)

	return result

try:
	target_dir=sys.argv[1]
	in_dir=sys.argv[2]
	substitutes=dict()
	substitutes['srcfile']=sys.argv[0]
	substitutes['date']=time.strftime('%Y-%m-%d %H:%M %Z')

	projinfo=load(in_dir + '/projectinfo.json')
	substitutes['projname']=projinfo['name']
	substitutes['acknowledgement']='","'.join(projinfo['acknowledgement'])
	substitutes['acknowledgement_all']='\\n'.join(projinfo['acknowledgement'])
	substitutes['author']=projinfo['author']
	substitutes['legal_brief']=projinfo['legal_brief']
	substitutes['years']=str(projinfo['years']).replace(', ','–').strip('[]')
	substitutes['revision']=get_revision(target_dir)
	substitutes['description']=projinfo['description']

	externals=load(target_dir + '/externals.json')
	substitutes['libraries']='","'.join(sorted( externals['libraries']) )
	substitutes['libstring']=', '.join(sorted( externals['libraries']) )
	substitutes['tools']='","'.join(sorted( externals['tools']) )

	config=load(target_dir + '/maikeconfig.json')
	substitutes['compiler']=compiler_version(compiler_name(config)).replace(' ','\xa0')
	substitutes['architecture']=config['targetinfo']['architecture']

	with open(target_dir + '/' + in_dir + '/projectinfo.hpp','wb') as output:
		output.write(projinfo_template.substitute(substitutes).encode('utf-8'))
	sys.exit(0)

except Exception:
	write_error('%s:%d: error: %s\n'%(sys.argv[0],sys.exc_info()[2].tb_lineno,sys.exc_info()[1]))
	sys.exit(-1)
