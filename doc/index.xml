<?xml version="1.0" encoding="UTF-8"?>
<document>
	<title>Anja user's guide</title>
	<subtitle>version <verbatiminput src="../versioninfo.txt" /></subtitle>
	<author>Torbjörn Rathsman</author>
	<titlepic>
		<includegraphics src="logo_3.png" media="(max-width:128px)" />
		<includegraphics src="logo_2.png" media="(max-width:256px)" />
		<includegraphics src="logo_1.png" media="(max-width:512px)" />
		<includegraphics src="logo.png" media="(min-width:512px)" />
	</titlepic>

	<input src="abstract.xml" />

	<input src="acknowledgements.xml" />

	<tableofcontents />

	<chapter-star id="notations">Notations</chapter-star>
	<p>The following table shows examples of notations used within this manual, or within Anja itself.</p>
	<tabular>
		<colheaders><col>Symbol</col><col>Meaning</col></colheaders>
			<row><col><includegraphics src="message_info.svg" /></col><col>The surrounding box may contain useful tips or shortcuts</col></row>
			<row><col><includegraphics src="message_warning.svg" /></col><col>The surrounding box contains information that will save you trouble</col></row>
			<row><col><includegraphics src="message_usererror.svg" /></col><col>You have done something in a wrong way. The surrounding box contains information about how you should fix it.</col></row>
			<row><col><includegraphics src="message_error.svg" /></col><col>The desired action failed. The surrounding box contains information about what went wrong.</col></row>
			<hline colspan="2"/>
			<row><col><kbd>Key</kbd></col><col>A key on the computer keyboard</col></row>
			<row><col><ui-button>Button</ui-button></col><col>A button in the user interface</col></row>
			<row><col><ui-formfield>Formfield</ui-formfield></col><col>An input field within the user interface</col></row>
			<row><col><char>#</char></col><col>A symbol with its Unicode® codepoint</col></row>
	</tabular>

	<chapter id="intro">Introduction</chapter>
	<p><strong>Anja</strong> is a sample player designed for live sound effect playback. Anja makes it possible to assign sound effects to the keys typing keys of the computer keyboard. To make it easier to find sound effects, each sound effect can have a description and a color, that shows up on Anja's virtual computer keyboard.</p>

	<p>Anja also features a channel mixer with 16 channels. All sound effects are routed through one of these channels. The channel mixer makes it possible to fade a group of sound effects together. As with sound effects, each channel has a color and a description. In addition to color, description and channel gain, each channel also has an adjustable fade time, that is used to automatically fade the channel.</p>

	<p>The backend of Anja is JACK, the low-latency audio server<cite>jack</cite>. This makes it possible to connect Anja to other JACK clients enabling the creation of more complex signal flows.</p>

	<p>The session file format of Anja described in more detail in <ref>sessfile</ref> is in a formalized text format, optimized for human readability. The syntax of the session files has taken inspiration from formats such as Markdown<cite>markdown</cite> and is very similar to the syntax used in the "Doom template file"<cite>doomwiki</cite>. Therefore, session files can be easiliy edited by hand in a text editor, to the price of somewhat larger session files.</p>


	<section id="requirements">System requirements</section>
	<p>To run Anja, a working installation of JACK<cite>jack</cite> is required. Moreover, Anja requires <libname>libsndfile</libname>, <libname>libsamplerate</libname> and <libname>GTK+</libname> version 3, together with <libname>gtksourceview</libname> version 3. A complete list of dependencies are found in <ref>deps</ref>.</p>

	<p>Anja currently only builds on x86-64. If possible, parts of the code can execute faster if Anja is compiled for an AVX capable CPU. Notice that a version that has been compiled for such a CPU cannot run on a CPU without AVX support. This is because only one version of the audio engine is build during compilation.</p>

	<p>Since Anja completely loads all sound files referenced from a session file, it may consume some RAM. At <quantity unit="kHz">48</quantity>, the RAM usage is <quantity unit="MiB/min">11</quantity> of sound. The minimum screen resolution for running Anja is <quantity unit="px">1024</quantity> &#215; <quantity unit="px">768</quantity>.</p>


	<section id="comparison">Anja compared to other software</section>
	<p>There are other sample players that also may be used with JACK. One such program is Hydrogen<cite>hydrogen</cite>. Compared to Hydrogen, Anja lacks a sequencer. However, in Hydrogen, waveforms need to be assigned in a particular order, and Hydrogen does not feature an on-screen keyboard. Other features in Anja is event-triggerd auto-fade, and also an exposed <em>kill all</em> feature.</p>

	<chapter id="install">Installing Anja</chapter>

	<p>Before Anja can be used, the program needs to be installed. This chapter goes through the installation procedure.</p>

	<section id="installlinux">Installing on a GNU/Linux system</section>

	<p>On GNU/Linux, the recommended way of installing Anja is to install it from the software repository. If there is no package available, download the source package<cite>anjasrc</cite>, and compile it as according to the instructions in <ref>compile</ref>.</p>

	<section id="compile">Compiling Anja</section>
	<p>Before Anja can be compiled, certain programs, and libraries are needed. These are listed in <ref>deps</ref>. Observe that some of the libraries may be split into a runtime package, and a development package. In this case you must install both parts of the library. On Ubuntu, these packages usually have the suffix <em>dev</em>. Anja has been written using the <prgname>maike</prgname> build tool. Therefore, this program has to be available when Anja is compiled. The <dfn>makefile</dfn> distributed with Anja, tries to detect <prgname>maike</prgname> before the compilation starts. If the <dfn>makefile</dfn> fails to detect <prgname>maike</prgname>, a package containing <prgname>maike</prgname> is downloaded from the author's GitHub repository by using <prgname>wget</prgname> and <prgname>jq</prgname>.</p>

	<infobox type="info">In addition to the general instructions given here, there are some additional information regarding build preparation in the file <dirname>README.md</dirname>.</infobox>

<p>As mentioned above, the Anja source package can be obtained from<cite>anjasrc</cite>. Following this link gives a link to a gzipped tarball. In order to extract that tarball issue the command</p>

	<code language="bash">tar -xf anja-src.tar.gz</code>

	<p>This will create a directory <dirname>anja</dirname>, in current directory. Now <prgname>cd</prgname> into that directory and run <prgname>make</prgname>:</p>

	<code language="bash">cd anja-src
make</code>

<p>When running <prgname>make</prgname>, files are written to <dirname>__targets_*</dirname>. After the compilation has completed, Anja can be launched directly by running the command</p>

<code language="bash">./anja</code>

<infobox type="warning">Normally, Anja is distributed with pre-rendered images. It may happen that the corresponding <prgname>blender</prgname> file has been updated and the render. In this case, it will take a much longer time than normal to compile Anja, since the images will need to be rerendered.</infobox>

	<p>To make it easier to launch Anja, you can move (or copy) the script, <em>and the binaries it refers to</em> to a place mentioned in the <env>PATH</env> variable. For example, a simple install (without desktop icon and manpage) could look like</p>

<code language="bash">cp ./anja ~/bin/anja
for k in __anja_*; do
	mkdir ~/bin/"$k"
	cp "$k"/anja ~/bin/"$k"
done</code>

	<p>If you have <prgname>sudo</prgname> permissions, you can do</p>
<code language="bash">sudo make install</code>
<p>This will perform a regular install, for all users.</p>

	<chapter id="using">Using Anja</chapter>

	<p>Starting Anja brings up a window that looks like the one presented in <ref>anjastart</ref>. The workspace consists of four main parts outlined in <ref>anjaworkspace</ref>. At the top, there is a <dfn>status area</dfn>, showing the state of Anja. Below that, there are two columns. The leftmost column contains the <dfn>action panel</dfn> with different buttons that affect Anja's current state. To the right of that, the <dfn>keyboard view</dfn> is located, and below that, there is a <dfn>settings panel</dfn>, controlling which waveforms are loaded as well as the playback of loaded waveforms.</p>

	<figure id="anjastart">
		<includegraphics src="mainwindowstart.png" />
		<caption>The Anja window, as shown after launching Anja without any command line arguments, and with a JACK server running.</caption>
	</figure>

	<figure id="anjaworkspace">
		<includegraphics src="anja_layout.svg" />
		<caption>The different parts of the Anja workspace. At the top, there is a <dfn>status area</dfn> showing the state of Anja. To the left is the <dfn>action panel</dfn>, used to control Anja's state. To the right is the <dfn>keyboard view</dfn>, which selects waveform slots and channels, and below that is the <dfn>settings panel</dfn>, which is used to load waveforms and control the playback of loaded waveforms.</caption>
	</figure>

<section id="statusarea">The status area</section>
	<p>The <dfn>status area</dfn>, shown larger in <ref>statusareacut</ref>, contains four parts as illustrated by <ref>statusareafig</ref>. The engine status and the keyboard status indicators should be self-explanatory: red <includegraphics src="led_stop.png"/> means that it is not ready, and green <includegraphics src="led_ready.png"/> that it is ready. A similar convention holds for the <dfn>port status area</dfn> (see <ref>chstatus</ref> for more details). In addition to being in the state of usable or not usable, ports are of different types: MIDI or Wave, input or output. MIDI ports have red-shaded background, while Wave ports have a blue-shaded background. Input ports are located to the left, and output ports are located to the right. Between the input and output sections, there are indicators with neutral or non-highlighted background. These represent the 16 internal Wave ports.</p>

	<figure id="statusareacut">
		<includegraphics src="statusarea.png" />
		<caption>A detailed view of the <dfn>status area</dfn>. The <dfn>status area</dfn> contains four panels: An engine status indicator, port status indicators, a keyboard status indicator, and a memory usage indicator.</caption>
	</figure>

	<figure id="statusareafig">
		<includegraphics src="statusarea.svg" />
		<caption>Layout description of the <dfn>status area</dfn>.</caption>
	</figure>

<p>The memory usage indicator uses high-saturated colors for memory used by the current instance of Anja. The amount of memory used by other processes uses low-saturated colors. The level indicator is divided into two parts: RAM and swap. The RAM part is green, while the swap part is red.</p>

<infobox type="warning">You do <em>not</em> want Anja to spill over into the swap space, since it can result in long delays between pressing triggering playback, and actual sound output. Also, it can result in sound dropout from other processes running on the same JACK server.</infobox>

<section id="addfx">Loading a waveform</section>
	<p>To load a waveform, choose a slot by clicking on the corresponding key in the <dfn>keyboard view</dfn> (see <ref>anjaworkspace</ref>). It is possible to choose any typing key except system keys and the space bar. After choosing a key <kbd><var>K</var></kbd>, the corresponding key will be highlighted. Now click <ui-button>Browse…</ui-button> to the right of <ui-formfield>Source</ui-formfield> field now visible in the <dfn>settings panel</dfn> (see <ref>anjastart</ref>). This brings up a file selection dialog. It is also possible to type a filename directly in the text input field to the left of <ui-button>Browse…</ui-button>.</p>

<infobox type="info">In case a multi-channel audio file is loaded, all channels in the input stream are mixed into one. This is because Anja uses mono waveforms. If you want to preserve individual channles, separate the channels of the input file with a tool such as <prgname>ffmpeg</prgname> and load the resulting files into different slots, mapped to different channels. Then use multi-channel output (see <ref>multichannel</ref>) and trigger playback of these slots simultaneously.</infobox>

<infobox type="warning">Anja does not resample any waveform during playback. Instead, it will resample waveforms that do not match the current sample rate when the engine is started. If the engine has to be restarted and the new sample rate differs (the only reason for this is that JACK itself was restarted using another sample rate), it is recommended to save the current session and reload it rather than restarting the engine. This is because multiple resample steps can be lossy.
</infobox>

	<section id="play">Playing waveforms</section>
	<p>Before any sound can be heard from Anja, the following conditions has to be met:</p>

	<ul><li>The <dfn>audio engine</dfn> has to be running</li>
	<li>The output of Anja has to be connected to a suitable system playback port</li>
	<li>The corresponding playback channel has to be unmuted, and have a non-zero gain. For more information, see <ref>pbchannel</ref> and <ref>chmixer</ref>.</li>
	<li>The workspace must accept keyboard input (see <ref>keybstatus</ref>), or the MIDI input port must be connected to a MIDI event source (see <ref>midi</ref>)</li></ul>

<subsection id="engstatus">Controlling and manipulating engine status</subsection>

	<p>As stated in <ref>statusarea</ref>, the state of the engine is showed by the leftmost panel in the <dfn>status area</dfn>. If a JACK server was already running when Anja was started, the engine should be running already. Otherwise, make sure that there is a JACK server running, and click the button <ui-button>Start engine</ui-button> in the <dfn>action panel</dfn> (see <ref>anjaworkspace</ref>). Now, there should be a new JACK client with a name that derived from the name of the current Anja session. For example, after starting the engine on the default session, there should be a JACK client called <env>New session.anja</env>.</p>

<subsection id="connections">Connecting Anja to system playback</subsection>
	<p>By default, Anja has two output ports: <dirname>Master out</dirname> and <dirname>Audition</dirname>. The difference between these ports is what sound that are routed to them. <dirname>Master out</dirname> is the main output, in the sense that all playback triggered by regular key input and MIDI (see <ref>midi</ref>) will be routed to this port. The <dirname>Audition</dirname> port is used for playback of the current slot (in <ref>addfx</ref> the slot mapped to key <kbd><var>K</var></kbd>), triggered by hitting <kbd>Space</kbd>.</p>

	<infobox type="info">
	Notice that hitting <kbd>Space</kbd> bar will never output any sound to <dirname>Master out</dirname>. This makes it possible to pre-listen to sounds without routing them to a PA system.
	</infobox>

<p>The connection status of <dirname>Master out</dirname> and <dirname>Audition</dirname> is shown by the two indicators with blue-shaded background in the output section of the <dfn>port status area</dfn> (see <ref>statusareacut</ref> and <ref>statusareafig</ref>). When the engine is not running, these are black <includegraphics src="led_off.png" />. When the engine is running, a non-connected port is indicated by a yellow <includegraphics src="led_wait.png" /> light, and a connected port is indicated by a green <includegraphics src="led_ready.png"/>. For more details about port status indicators, see <ref>chstatus</ref>.</p>

<figure id="portselector">
	<includegraphics src="portselector.png" />
	<caption>The port selection dialog. To route the signal to a port, toggle the corresponding button. The choices are confirmed by clicking <ui-button>OK</ui-button>.</caption>
</figure>

<p>A port can be connected to other ports in the system by clicking on the corresponding status indicator. This brings up a dialog box that contains toggle buttons for all availible ports (see <ref>portselector</ref>). Click <ui-button>OK</ui-button> to confirm your choicee.</p>

<infobox type="info">JACK ports can be connected by using the command <prgname>jack_connect</prgname><cite>manjack</cite>. To connect the mentioned ports to a pair of system playback ports. the commands would be
<code language="bash">jack_connect 'New session.anja:Master out' 'system:playback_1'
jack_connect 'New session.anja:Audition' 'system:playback_2'
</code>
Then, Anja will use the "Left" channel as main output, and the "Right" channel as Audition.</infobox>

<infobox type="info">Instead of using the command line, it is possible to use a JACK patchbay tool such as <prgname>Catia</prgname><cite>catia</cite>. In <prgname>Catia</prgname> ports can be connected using "Drag and drop".</infobox>


<subsection id="keybstatus">Activating the keyboard</subsection>
<p>Since the keyboard is shared between the playback triggering system and form input fields, playback can only be triggered from the keyboard when keyboard triggering is active. The <dfn>keyboard status indicator</dfn> (see <ref>statusarea</ref>) is red <includegraphics src="led_stop.png"/> when a form input field has keyboard focus, and green <includegraphics src="led_ready.png"/> when playback triggering is active. Keyboard triggering is activated by hitting <kbd>ESC</kbd>, or by clicking anywhere on the workspace that would not capture keyboard focus.</p>

<section id="rec">Capturing waveforms</section>
<p>Similar to waveform playback (see <ref>play</ref>), waveform capture requires that the audio engine is started. In order to capture a waveform, make sure that <dirname>Wave in</dirname> is connected to a signal source by clicking on the indicator for <dirname>Wave in</dirname>. That is, the leftmost indicator in the <dfn>port status area</dfn> (see <ref>statusarea</ref>). Then press <kbd>Ctrl</kbd> and the typing area key <kbd><var>K</var></kbd> that should be used for playing the captured waveform. If the <kbd>Ctrl</kbd> is released before the typing area key, playback of the recorded waveform is triggered. If <kbd><var>K</var></kbd> is released first, the capture process is stoppped.</p>

<infobox type="info">Triggering audio capture from the computer keyboard is only possible when keyboard triggering is active. When it is active, the <dfn>keyboard status indicator</dfn> is green <includegraphics src="led_ready.png"/>. Otherwise, it is red <includegraphics src="led_stop.png"/>.</infobox>

<infobox type="info">It is not possible to record waveforms to a slot that has been marked as read-only. See <ref>waveformprop</ref> form more information.</infobox>

<infobox type="warning">Captured waveforms are stored the waveform in virtual memory. This means that it is not possible to record longer waveforms. Also, trying to do so may crash Anja. See <ref>requirements</ref> for information about memory requirements.</infobox>

<section id="waveformprop">Configuring waveform playback</section>
<p>The playback behaviour and other properties can be controlled through the <dfn>waveform tab</dfn> in the <dfn>settings panel</dfn> (see <ref>anjaworkspace</ref>). An enlarged view of the <dfn>waveform tab</dfn> after loading a waveform file is shown in <ref>waveformsettings</ref>. This view is activated by clicking on the corresponding key on the keyboard view.</p>

<figure id="waveformsettings">
	<includegraphics src="waveformsettings.png" />
	<caption>An enlarged view of the <dfn>settings panel</dfn> showing the <dfn>waveform tab</dfn>, after loading a waveform file. This tab contains various settings controlling playback of the selected slot.</caption>
</figure>

<subsection id="wavesource">Source file selection</subsection>
<p>The source file is chosen through the <ui-formfield>Source</ui-formfield> field. By clicking <ui-button>Browse…</ui-button>, a file selection dialog appears. When a different waveform file is selected Anja replaces the waveform associated with current slot, with the waveform loaded from the chosen file. For information about supported file formats, see <ref>fileformats</ref>.</p>

<infobox type="info">
	It is not possible to load another waveform when the current slot is in use by the engine.
</infobox>

<infobox type="info">
	Changing the source file on disk without clicking on the reload button <ui-button>↺</ui-button> does not affect Anja, since Anja loads a copy of the file content into memory.</infobox>

<infobox type="warning">
	Avoid loading large files. Doing so, may exhaust system memory. See <ref>requirements</ref> for information about memory requirements.
</infobox>

<subsection id="description">Waveform description</subsection>
<p>It is possible to assign an arbitrary description to the waveform slot through the <ui-formfield>Description</ui-formfield> field. The description does not affect the waveform playback, but makes it easier to find the waveform in the <dfn>Keyboard view</dfn>.</p>

<p>It may happen that the description is long. Therefore it is possible to mark a key-phrase by surrounding it with square brackets. Then, only the text within the first pair of square brackets will appear at the virtual key. If there are no square brackets within the description, the first word will be used instead.</p>

<subsection id="wavecolor">Waveform color</subsection>
<p>Like description (see <ref>description</ref>), the <ui-formfield>Color</ui-formfield> field is only used for visual enhancements. The color is given as red-green-blue-alpha values delimited by <char>;</char>, where each component is in the range [0, 1]. If the <ui-button>…</ui-button> is pressed, a color selection dialog based on the HSL color system appears.</p>

<infobox type="info">
	The idea behind color coding of waveform slots is that slots that are used in similar context can be encoded with a similar color. The color coding feature can be used to categorize different kinds of waveforms such as <var>Fx</var>  and <var>Ambient</var>.
</infobox>

<subsection id="pbchannel">Playback channel</subsection>
<p>The <ui-formfield>Channel</ui-formfield> field assigns a channel to the waveform slot. All sound from this slot will be routed through the selected channel.</p>

<infobox type="info">
	Channels can be used to fade multiple sound sources together. The mix of all channels can either be controlled by the internal <dfn>channel mixer</dfn> (see <ref>chmixer</ref>), or by an external mixer (see <ref>multichannel</ref>).
</infobox>

<subsection id="pbgain">Playback gain</subsection>
<p>Before the signal reaches the strip for the selected playback channel (see <ref>pbchannel</ref>), the signal is amplified by the given playback gain. The gain can be adjusted from <quantity unit="dB">-72</quantity> to <quantity unit="dB">6</quantity>.</p>

<subsection id="pbgainrandom">Playback gain randomization</subsection>
<p>In addition to deterministic playback gain adjustment, it is possible to add a non-deterministic component to the playback gain. The  parameter <ui-formfield>Gain random</ui-formfield> sets how much the random component is amplified.</p>

<infobox type="info">Depending on the state of the <ui-formfield>Set gain on loop</ui-formfield> flag (see <ref>pboptgainrand</ref>), new random numbers are drawn on manual re-triggering, or for each iteration when playback loop is active. This can be useful for creating a more "living" sound.</infobox>

<subsection id="pboptions">Controlling playback behavior</subsection>
<p>There are different options for controlling the playback behavior. These are <dfn>Loop</dfn>, <dfn>Sustain</dfn>, <dfn>Readonly</dfn>, and <dfn>Set gain on loop</dfn>.</p>

<subsubsection id="pboptloop">Loop</subsubsection>
<p>When <dfn>Loop</dfn> is enabled, playback will start form the <dfn>loop begin cursor </dfn> when the playback position reaches the <dfn>loop end cursor</dfn>, if no stopping event has occurred before that happens. For more information about adjusting cursors, see <ref>rangeadjust</ref>.</p>

<subsubsection id="pboptsustain">Sustain</subsubsection>
<p>The <dfn>Sustain</dfn> flag controls whether or not a key release event should also send a stop event. When the <dfn>Sustain</dfn> flag is set, a stop event is not sent, emulating the effect of a pushed sustain pedal. </p>

<subsubsection id="pboptreadonly">Readonly</subsubsection>
<p>The <dfn>Readonly</dfn> flag controls whether or not it is possible to overwrite a loaded waveform with captured audio (see <ref>rec</ref>). Enabling <dfn>Readonly</dfn> prevents that a loaded waveform is accidentally overwritten by a record command.</p>

<subsubsection id="pboptgainrand">Set gain on loop</subsubsection>
<p>As mentioned in <ref>pbgainrandom</ref>, it is possible to only randomize gain on the trig event, but it is also possible set a new gain for each iteration in a loop. When this flag is set, the latter happens.</p>

<subsection id="rangeadjust">Adjusting playback or loop range</subsection>
<p>It may happen that only a part of a loaded waveform is interesting for playback or loop. With the <dfn>trim panel</dfn> (see <ref>trimpanel</ref>), it is possible to select the part of the waveform that should be played or looped. The graph shows in dB<sub>FS</sub>, the root mean square signal power integrated over <quantity unit="ms">1</quantity>, as a function of time in seconds. On top of the function graph, there are four cursors showing playback and loop range, as well as the <dfn>auto-trigger threshold level</dfn>. In addition to the plot window, there are four input fields that can be used to set playback cursor positions by entering the corresponding time position in seconds. The leftmost input field <ui-formfield>↦</ui-formfield> sets the <em>begin</em> position. The next input field, <ui-formfield>↪</ui-formfield>, sets the <em>loop begin</em> position. The next two input fields, <ui-formfield>↩</ui-formfield> and <ui-formfield>⇥</ui-formfield>, controls <em>loop end</em> and <em>end</em> respectively. Between the <em>begin</em> part and <em>end</em> section is a toggle button that toggles reversed playback.</p>

<figure id="trimpanel">
	<includegraphics src="waveformtrim.png" />
	<caption>The <dfn>trim panel</dfn>. Together with cursor positions, the plot window shows in dB<sub>FS</sub>, the root mean square signal power integrated over <quantity unit="ms">1</quantity> as a function of time in seconds. Below the plot window there are four input fields that sets the positions of the playback cursors. </caption>
</figure>

<infobox type="info">
Notice that when a cursor is located at the same position as another cursor, it might be obscured by the other cursor. This is why there are only three cursors visible in <ref>trimpanel</ref>.
</infobox>

<figure id="playseq">
	<includegraphics src="playseq.svg" />
	<caption>The playback sequence. Playback starts at the <em>begin</em> cursor and passes the <em>loop begin</em> cursor. When the playback position reaches the <em>loop end</em> cursor, and loop is activated and the engine has not received a stop message, the playback will continue from <em>loop begin</em> when it reaches <em>loop end</em>. Otherwise, playback continues until <em>end</em> is reached, or a stop message is received.</caption>
</figure>

<p>Before going into the details on how to set playback and loop ranges, it is good to get an overview of the playback sequence illustrated in <ref>playseq</ref>. Playback starts at the <em>begin</em> cursor and passes the <em>loop begin</em> cursor. When the playback position reaches the <em>loop end</em> cursor, and loop is activated and the engine has not received a stop message, the playback will continue from <em>loop begin</em> when it reaches <em>loop end</em>. Otherwise, playback continues until <em>end</em> is reached, or a stop message is received.</p>

<infobox type="warning">If the <em>loop begin</em> cursor coincides with <em>loop end</em> cursor, the loop range becomes empty and there will be no audible loop.
</infobox>

<subsubsection id="cursorpositions">Setting cursor positions</subsubsection>
<p>The primary way of setting the position of a cursor is to drag the cursor into position. The position of the <em>begin</em> is controlled by the green solid cursor and the position of the <em>loop begin</em> is controlled by the green dashed cursor. The end cursors are drawn the same way but in red instead of green.</p>

<infobox type="info">If it is hard to position a cursor sufficiently exact, try pressing <kbd>Ctrl</kbd> or <kbd>Shift</kbd> while using the mousewheel. This will zoom in or out in the <var>x</var> or <var>y</var> directions. Dragging inside the plot window, but not near a cursor, will translate the view window. Right-clicking in the plot window will reset the view to its initial state.
</infobox>

<p>Another way of adjusting the cursor positions is to drag the auto-triggering cursor while pressing <kbd>Shift</kbd>. This will move the <em>begin</em> and <em>end</em> cursors to the first or last position where the signal power exceeds the current threshold level. If this requires that the loop cursors to move, they will be pushed by the non-loop cursors.</p>

<infobox type="info">It is possible to use the auto-trigger threshold to set both the playback range and the loop range individually as long as the loop range is set given a higher threshold level. Since the auto-trigger only moves the <em>begin</em> and <em>end</em> cursors, but doing so may push the loop cursors to new positions, it is possible to push the loop cursors inwards to a certain position. When lowering the auto-trigger threshold, the loop cursors stays, but the other cursors move outwards.
</infobox>

<infobox type="info">If <kbd>Shift</kbd> is not pressed when the auto-triggering cursor is moved, no automatic adjustment is applied. This way, the auto-triggering cursor can be used as a guide for positioning the cursors manually.
</infobox>

<p>A third option is to enter cursors positions into the input fields below the plot window. The leftmost input field <ui-formfield>↦</ui-formfield> sets the <em>begin</em> position. The next input field, <ui-formfield>↪</ui-formfield>, sets the <em>loop begin</em> position. The next two input fields, <ui-formfield>↩</ui-formfield> and <ui-formfield>⇥</ui-formfield>, controls <em>loop end</em> and <em>end</em> respectively.</p>

<subsubsection id="revplayback">Reversed playback</subsubsection>
<p>Reversed playback is toggled by the middle button in the <dfn>trim panel</dfn> (see <ref>trimpanel</ref>). What it does is to swap the direction shown in <ref>playseq</ref> by reversing the list of cursor.  Another way of enabling reversed playback is to manually position the <em>end</em> cursors before the <em>begin</em> cursors. When <em>begin</em> and <em>end</em> cursors meats, the reverse toggle button changes state.</p>

<section id="chmixer">Configuring playback channels</section>

<p>The <dfn>Channel mixer</dfn> is shown in <ref>channelmixerfig</ref>. The <dfn>Channel mixer</dfn> controls the playback volume for the different playback channels. To the right of all channel strips, there is a master gain control, which controls the playback volume of the mixed channels. In addition to a gain control, each channel strip also contains an input field for selecting a channel color, which works similar to the color input field for waveforms (see <ref>wavecolor</ref>), and a control for determining the duration of automatic fade-in/out operations.</p>

<figure id="channelmixerfig">
	<includegraphics src="channels.png"/>
	<caption>The <dfn>Channel mixer</dfn>. Each channel strip has a label, a color, a fade time knob, and a volume slider. To the right of all strips, there is a master gain control, that affects the gain of the mix.</caption>
</figure>

<infobox type="info">
	It can be a good idea to match the channel colors in some way to the colors used for the waveform associated with the playback channel. This makes it easier to identify the playback channel for different waveform slots.
</infobox>

<infobox type="info">
	The knob uses an exponential mapping to increase precision for shorter time values. Also, it uses polar coordinates. If it is hard to find the right value, try to increase the distance from the cursor to the knob center when dragging the knob handle. It is also possible to enter values into the text entry field below the knob.
</infobox>

<p>Automatic fade-in/out is triggered by hitting <kbd>F<var>k</var></kbd> while pressing <kbd>↑</kbd>/<kbd>↓</kbd>, where <var>k</var> is the channel number. After fade-out, the channel is muted until it is unmuted or a fade-in occures. Mute and unmuting a channel is done by hitting the corresponding channel key (<kbd>F<var>k</var></kbd>) while pressing <kbd>←</kbd> or <kbd>→</kbd> respectively.</p>

<infobox type="info">
	It is only possible to access channel 1 to 12 from the PC keyboard. In order to auto-fade channel 13-16, an external MIDI controller can be used, see <ref>midi</ref>.
</infobox>

<infobox type="info">
	Using the PC keyboard to trigger fade-in/out is only possible when keyboard input is active. See <ref>keybstatus</ref> for more information.
</infobox>

<p>When a channel is muted and the engine uses single-channel output, the corresponding indicator in the <dfn>port status area</dfn> (see <ref>statusarea</ref>), is red <includegraphics src="led_stop.png" />. The same is true when the engine uses multi-channel output (see <ref>multichannel</ref>). In the case the engine uses multi-channel output and the corresponding port is not connected, the muted state is indicated by a black <includegraphics src="led_off.png" /> indicator. Unmuting the channel, reverts the corresponding indicator to its original state. All possible states of the port status indicators are listed in <ref>chstatus</ref>.</p>


<section id="multichannel">Multi-channel output</section>

<p>Anja has the option to use individual channel output. This enables the use of external effect processors on the different channels. To activate this feature, check the checkbox <ui-button>Use individual ports for each channel</ui-button> in the <dfn>session tab</dfn> (see <ref>sessprops</ref>), and restart the engine by clicking on <ui-button>Start engine</ui-button> in the <dfn>action panel</dfn> (see <ref>anjaworkspace</ref>). When individual ports are used for different channels, Anja creates one JACK port for each of the 16 channels in addition to <dirname>Master out</dirname> and <dirname>Audition</dirname>. These ports are connected in a similar way as described in <ref>connections</ref>, that is by clicking on the corresponding status indicator (see <ref>statusarea</ref>).</p>

<p>The signal sent to the channel-dedicated output ports are taken after the channel strip, but before the master gain adjustment. When activating multi-channel output, the port status indicators for the playback channels turns yellow <includegraphics src="led_wait.png" /> or black <includegraphics src="led_off.png" /> (depending on mute state) since the corresponding ports are not connected to any input port. However, the signal is still being routed to <dirname>Master out</dirname>. For a complete overview of the signal flow, see <ref>signalflow</ref>.
</p>

<infobox type="info">With JACK, it is possible to connect multiple output ports to one input port. In this case, JACK will sum over all inputs. To reduce the signal level after summation, other JACK tools such as <prgname>Non Mixer</prgname> can be used</infobox>

<section id="midi">Using MIDI</section>
<p>MIDI is a standard for communications between musical instruments, and other equipment<cite>mma</cite>. Through MIDI, Anja can be controlled by other MIDI enabled devices or software applications. To make it work, connect the <dirname>MIDI in</dirname> port to any MIDI output port such as <dirname>midi_capture_1</dirname>, and Anja will respond to external MIDI messages. Implementation details of different MIDI messages can be found in <ref>midiref</ref>.</p>

<p>Anja can also be used to control other MIDI enabled devices or software applications. To let Anja do so, connect <dirname>MIDI out</dirname> to a suitable MIDI input port on the device or software application you want to control. Anja posts the messages generated by the computer keyboard to <dirname>MIDI out</dirname>. The messages generated in different situations are listed in <ref>midiref</ref>.</p>

<infobox type="info">As with wave ports, MIDI ports can be connected by clicking on the corresponding status indicator (see <ref>connections</ref>). See <ref>statusarea</ref> for information about how to identify ports in the <dfn>status area</dfn>.</infobox>

<infobox type="info">
MIDI messages for playing notes are always tagged with a MIDI channel number. In Anja, the MIDI channels are the same as the playback channels (see <ref>pbchannel</ref> and <ref>chmixer</ref>). Thus, there are two sources for the channel number: the MIDI message itself, and the channel number of the slot referered to by the MIDI message. To resolve this, there is an option <ui-button>Allow external MIDI sources to set playback channel</ui-button> in the <dfn>session tab</dfn> (see <ref>sessprops</ref>).
</infobox>

<infobox type="info">
When <dirname>MIDI out</dirname> is connected to a MIDI input port, Anja resets the state of the receiver, and updates its channel volumes. This means that if the owner of the input port plays any note, there will be no more audio output from that device or software application until the next "note on" message comes.
</infobox>

<section id="sessprops">Modifying session properties</section>
<p>The <dfn>session tab</dfn>, shown in <ref>sesspropspanel</ref>, contains some session-wide settings. The <ui-formfield>Title</ui-formfield> is used to identify the session in the JACK patchbay. It is also possible give the session a <ui-formfield>Description</ui-formfield> that may contain other relevant information, such as a longer description, or legal information.</p>

<figure id="sesspropspanel">
	<includegraphics src="session.png"/>
	<caption>The <dfn>session tab</dfn>. From this tab, it is possible to give the session a title and a description, as well as enabling multi-channel output (see <ref>multichannel</ref>). </caption>
</figure>

<infobox type="info">
The session also has a set of properties that affects certain behaviour of Anja. For example, see <ref>multichannel</ref> and <ref>midi</ref>.
</infobox>

<infobox type="info">
	Both toggling multi-channel output and setting a new title requires the engine to be restarted.
</infobox>




	<bibliography>
		<item id="anjasrc">Anja source archive <url>https://github.com/milasudril/anja/releases/latest</url></item>
		<item id="jack">JACK Audio Connection Kit <url>http://jackaudio.org</url></item>
		<item id="markdown">Daring Firball: Markdown <url>https://daringfireball.net/projects/markdown</url></item>
		<item id="doomwiki">Doom file template <url>http://doom.wikia.com/wiki/Doom_file_template</url></item>
		<item id="hydrogen">Hydrogen <url>http://www.hydrogen-music.org/hcms</url></item>
		<item id="manjack"><prgname>jack_connect</prgname> manual page</item>
		<item id="catia">... <url>http://kxstudio.org</url></item>
		<item id="mma">MIDI Association <url>http://midi.org</url></item>
	</bibliography>

<appendix />

<chapter id="chstatus">Port status indicators</chapter>
<p>This table shows all states the port status indicators can have.</p>
<tabular>
	<colheaders><col>Indicator</col><col>Meaning</col></colheaders>
	<row><col><includegraphics src="led_off.png" /></col><col>Engine is not running</col></row>
	<row><col><includegraphics src="led_off.png" /></col><col>Channel is muted, and not connected to any port</col></row>
	<row><col><includegraphics src="led_wait.png" /></col><col>Channel is unmuted and not connected to any port</col></row>
	<row><col><includegraphics src="led_stop.png" /></col><col>Channel muted, and connected to some port</col></row>
	<row><col><includegraphics src="led_ready.png" /></col><col>Channel unmuted and connected to some port</col></row>
</tabular>

<chapter id="fileformats">Supported file formats</chapter>
	<p>Anja uses <libname>libsndfile</libname> in order to load waveform files. Thus the file formats supported by Anja, are the same as the file formats supported by <libname>libsndfile</libname>. If <libname>libsndfile</libname> does not support the file format of a particular waveform file, it can probably be converted to a supported file format by using <prgname>ffmpeg</prgname>. In such case, remember that you should not transcode to a lossy format (mp3 to ogg is bad), but rather to a lossless format (mp3 to wav is good).</p>

	<chapter id="keybindings">Key bindings</chapter>
	<p>These are the key bindins used in Anja. Notice that any of these except <kbd>ESC</kbd> requires that the computer keyboard is active.</p>
	<tabular>
		<colheaders><col>Key combination</col><col>Function</col></colheaders>
		<row><col><kbd>Ctrl</kbd>+<kbd><var>key</var></kbd></col><col>Record to <kbd><var>key</var></kbd></col></row>
		<row><col><kbd>ESC</kbd></col><col>Activate the computer keyboard. Hit this key if other keys in this list have no effect.</col></row>
		<row><col><kbd>DEL</kbd></col><col>Stop all audio playback on <dirname>Master out</dirname> or channel ports</col></row>
		<row><col><kbd><var>key</var></kbd></col><col>Start playback of the slot associated with <var>key</var></col></row>
		<row><col><kbd>Page Down</kbd></col><col>Stop all audio playback on <dirname>Audition</dirname></col></row>
		<row><col><kbd>Space</kbd></col><col>Start audition playback of current slot</col></row>
		<row><col><kbd>↑</kbd> + <kbd>F<var>k</var></kbd></col><col>Fade in channel <var>k</var></col></row>
		<row><col><kbd>↓</kbd> + <kbd>F<var>k</var></kbd></col><col>Fade out channel <var>k</var></col></row>
		<row><col><kbd>←</kbd> + <kbd>F<var>k</var></kbd></col><col>Mute channel <var>k</var></col></row>
		<row><col><kbd>→</kbd> + <kbd>F<var>k</var></kbd></col><col>Unmute channel <var>k</var></col></row>
	</tabular>

<chapter id="signalflow">Signal flow</chapter>
<p>The following graph illustrates the signal flow of Anja.</p>
<herefigure><includegraphics src="signalflow.svg" /></herefigure>

<chapter id="midiref">MIDI message processing</chapter>
<p>The following table lists all MIDI messages that Anja processes, and how they are processed.</p>
<tabular>
	<colheaders><col>Message</col><col>Control code</col><col>Anja's response</col></colheaders>
	<row><col>NOTE_OFF</col><col>N/A</col><col>Stop all playback that is associated with the given key</col></row>
	<row><col>NOTE_ON</col><col>N/A</col><col>If possible, start playback using the slot given by the first data byte. If channel override is allowed (see <ref>midi</ref>), the mapped waveform will be played through the channel given by the message. Otherwise, the it is played through the channel set by anja (see <ref>pbchannel</ref>).</col></row>
	<row><col>CONTROL_CHANGE</col><col>CHANNEL_VOLUME</col><col>Set playback channel volume. Notice that Anja assumes that the value is a linearly mapped dB value (0 corresponds to <quantity unit="dB">-72</quantity>, 127 corresponds to <quantity unit="dB">6</quantity>), as opposed to General MIDI, which says that the value should be a regular gain. The reason for this implementation is to make better use of the seven bits available in a single channel volume message.</col></row>
	<row><col> </col><col>SOUND_OFF</col><col>Stop all ongoing playback. If The last data byte is non-zero, it stops all <dirname>Audiotion</dirname> playback. Otherwise, all other playback is stopped.</col></row>
	<row><col> </col><col>GENERAL_PURPOSE_1</col><col>Start a fade out on the given channel. The second data byte controls the decay rate.</col></row>
	<row><col> </col><col>GENERAL_PURPOSE_2</col><col>Start a fade in on the given channel. The second data byte controls the decay rate.</col></row>
	<row><col> </col><col>GENERAL_PURPOSE_3</col><col>If possible, enable recording to the slot given by the second data byte. If recording is already enabled, the last block of the current recording is discarded.</col></row>
	<row><col> </col><col>GENERAL_PURPOSE_4</col><col>If possible, disable recording to the slot given by the second data byte</col></row>
</tabular>

<input src="cmdline.xml" />

<chapter id="sessfile">Session file format</chapter>
<p>Anja session files are plain text files, that contains all session properties, waveform settings, and channel settings. Session files do not contain any waveforms. Instead they refer to the file that contains the actual waveform. The idea is that the session file acts as a machine-readable readme file, that is somehow bundled with the waveform files. Thus, the session file should be very easy to be read by humans.</p>

<p>For an example of what a session file might look like, see <dirname>testbank/testbank.txt</dirname> in the source repository. The file is organized as a hierarchical key-value store. Section headers begin with a number of consecutive <char>#</char>, which have to appear as the first non-whitespace character on a line. The header ends with a newline character. The section level is the same as the number of characters used to begin the header. A key begins with a <char>~</char>, which similarly to the section header delimiter, has to be the first non-whitespace character on the line, and ends with <char>:</char> or a newline character. After the ending delimiter, follows the associated value. At any point, a <char>\</char> can be used if a delimiter should be processed literally.</p>

<p>In general, any character that has no particular meaning in the current context, can be used without escaping. To make it possible to write session files in a more readable way, some special rules apply to whitespaces. Whitespaces immediatly following a delimiter or another whitespace, are ignored. As mentioned above, newline characters cannot appear unescaped in keys. In values, two or more newline characters that are only separated by other whitespace characters, are collapsed into two newline characters. Unescaped single newlines are treated in the same way as any whitespace.</p>

<p>If the first key in a section is <dirname>Description</dirname>, it is possible to ommit the key, and write its value right after the section header. This makes it possible to write session files more like a regular document.</p>

<input src="dependencies.xml" />

<chapter id="script">Commands accepted in scripts</chapter>
<p>With the <cmdoption>--script</cmdoption> (see <ref>cmdline</ref>), it is possible to perform some tasks when starting Anja. This option has been added to make it possible to generate relevant screenshots for this manual. This means that only features that are needed for that purpose are currently implemented. Also, the syntax may change in a future release and it is not very tolerant with respect to whitespace. Nevertheless, this appendix contains a list of all implemented commands.</p>

<ul>
<li class="cmdoption"><p><cmdoption>layout inspect</cmdoption></p>
<p>prints coordinates of bounding boxes for various parts of the GUI to standard output. The outline in <ref>anjaworkspace</ref> has been generated by using this command.</p></li>

<li class="cmdoption"><p><cmdoption>port selector open</cmdoption>,<em>port indicator index</em></p>

<p>opens the <dfn>port selector dialog</dfn> (see <ref>portselector</ref>) as if the user clicked on the port status indicator in the <dfn>status area</dfn> (see <ref>statusarea</ref>), with the given index</p></li>

<li class="cmdoption"><p><cmdoption>port selector close</cmdoption></p>
<p>closes any open <dfn>port selector dialog</dfn></p></li>

<li class="cmdoption"><p><cmdoption>waveform load</cmdoption>,<em>slot</em>,<em>filename in</em></p>
<p>Loads <em>filename in</em> into <em>slot</em>, where slot is an integer in [0, 128[</p></li>

<li class="cmdoption"><p><cmdoption>session load</cmdoption>,<em>filename in</em></p>
<p>Loads the session <em>filename in</em></p></li>

<li class="cmdoption"><p><cmdoption>settings</cmdoption>,<em>tab</em></p>
<p>Reveals <em>tab</em>, where <em>tab</em> is one of <cmdoption>waveform</cmdoption>, <cmdoption>channels</cmdoption> and <cmdoption>session</cmdoption></p></li>
</ul>

<chapter id="srcview">Source code overview</chapter>
<p>The source code of Anja is divided into three major components: Engine, Session data storage, and UI. The engine is the component that communicates with JACK. The session data component is responsible for disk I/O of session and waveform files. The UI code handles the user interface. In addition to these components, there are in the repository, some more general classes, MIDI interaction helper files, resource files, test data, and also the source files for this manual. These file categories are represented by a directory, which contains all of its files.</p>

<section id="modintract">Component interaction</section>
<p>The component interaction is illustrated in <ref>modinteractfig</ref>. It is the engine and the UI that are the "active" components. When a setting is changed, the UI will modify the corresponding field in the session data. If that change should affect another part of the UI, the UI will update the relevant parts itself. When the engine needs a waveform and its parameter values, it will fetch these from the session data component. This direct approach makes the code easier to follow and keeps the session data component clean, but requires changes at more places in the code, compared to an orthodox MVC approach, where the model updates all registered views upon a succeeded change request.</p>

<figure id="modinteractfig">
	<includegraphics src="modinteract.svg" />
	<caption>Component interaction in Anja. The engine and the UI are the active components, while the session data component acts as a passive data store.</caption>
</figure>

<p>When the user triggers the engine, the UI posts a MIDI message, by calling <function>Engine::messagePost</function>, to a ringbuffer, which is read by the realtime thread in the engine. The messages are then processed by the engine. Some actions requires that the engine updates the UI. This problem is solved by another FIFO with two post methods: <function>UiContext::messagePost</function> and <function>UiContext::messagePostTry</function>. The former will block until the message can be processed, while the latter will simply fail if the message cannot be processed. Thus, from any realtime context, the latter must be used.</p>

<p>Some requests to the session data component may take a longer time. In this case it is possible to pass a progress callback object to the affected method. Typically, the callback object will be some of the UI objects, but there is no explicit association from the session data component to the UI component.</p>

<section id="uiframework">The design of the UI component</section>
<p>The UI component has been designed to hide as much as possible about the underlying framework, while trying to preserve the native look and feel. This means that no widget exposes the internal handle, and most of the common UI widgets, i.e. buttons, checkboxes, comboboxes, labels, sliders, and text input fields, are nothing more than thin wrappers on top of the framework. Also, the file selection dialog belongs to this category. Widgets that have a sematic difference between different platforms, are emulated using these basic widgets. As an example, listboxes are emulated using a <class>ButtonList</class>, which itself consists of a set of buttons. Some widgets such as the <class>XYPlot</class> are completely missing from common UI frameworks. In this case, they have been implemented directly at top of the framework. This is because it is hard to construct a general abstraction on top of a drawing API.</p>

<p>In addition to widgets, there are "containers". A container is any class that implements the <class>Container</class> interface. Since some frameworks, such as the classic Windows API, is easiest to work with if the container is created before its children, and this design is more restrictive than creating the widgets before the container, Anja uses the container-first priciple. Notice that  unlike in <libname>GTK+-3.0</libname>, <em>containers are not widgets</em>. In fact, there is no exposed <class>Widget</class> base class, since the only polymorphic behaviour required by widgets, positioning, are handled by the framework.</p>

<p>Event handlers are registered by passing a callback object and an id, to the widget of interest. Different widget has different requirement of the callback object. More information about this topic can be found in the include file for the widget.</p>

<p>Modal dialog boxes are emulated as modeless dialogues that disables the main window. The <class>Dialog</class> is a template that owns a widget, and some buttons specified by a dialog trait. Event handlers for the buttons are handled in a similar way as for widgets. A callback object is assigned to the dialog, and when the user activates a button, the corresponding method on the callback object is invoked.</p>

<input src="legalbrief.xml" />
</document>
